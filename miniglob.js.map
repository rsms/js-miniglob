{
  "version": 3,
  "sources": ["src/miniglob.js", "src/miniglob.js"],
  "sourcesContent": ["//\n// miniglob is a port of golang path/filepath\n//\n// Original Go source code Copyright (c) 2009 The Go Authors.\n// All rights reserved. See LICENSE-go for complete license.\n//\n// This code licensed under MIT, Copyright (c) 2018 Rasmus Andersson.\n// See LICENSE for complete license.\n//\nconst { readdirSync, statSync } = require('fs')\nconst DIRSEP = (() => {try {return require('path').sep}catch(_){return '/'}})()\nconst DIRSEP_BYTE = DIRSEP.charCodeAt(0)\nconst DIRSEP_RE_PG = DIRSEP == ':' ? /\\:+/g : DIRSEP == '\\\\' ? /\\\\+/g : /\\/+/g\nconst WIN32 = process.platform == 'win32'\n\n\nexport class PatternError extends Error {\n  constructor() { super('bad pattern') }\n}\n\n\nexport function glob(pattern) {\n  if (pattern.indexOf(\"**\") < 0) {\n    return glob0(pattern)\n  }\n  let matches = []\n  let filesVisited = new Set()\n  deepglob('', pattern.split(/\\*{2,}/), 0, matches, filesVisited)\n  return matches\n}\n\n\nfunction log() {\n  // console.log.apply(console, arguments)\n}\n\n\n// volumeNameLen returns length of the leading volume name on Windows.\n// It returns 0 elsewhere.\nconst volumeNameLen = WIN32 ? path => {\n  if (path.length < 2) {\n    return 0\n  }\n  // with drive letter\n  let c = path[0]\n  if (path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z')) {\n    return 2\n  }\n  // TODO: check for UNC\n  return 0\n} : path => 0\n\n\n// cleanGlobPath prepares path for glob matching.\n// cleanGlobPath(path :string) : [prefixLen int, cleaned string]\n//\nconst cleanGlobPath = (\n  WIN32 ? (path, volumeNameLen) => { // (prefixLen int, cleaned string)\n    let vollen = volumeNameLen(path)\n    if (path == \"\") {\n      return [0, \".\"]\n    }\n    if (vollen+1 == path.length && isPathSep(path, path.length-1)) {\n      // /, \\, C:\\ and C:/ -- do nothing to the path\n      return [vollen + 1, path]\n    }\n    if (vollen == path.length && path.length == 2) { // C:\n      return [vollen, path + \".\"] // convert C: into C:.\n    }\n    if (vollen >= path.length) {\n      vollen = path.length - 1\n    }\n    return [vollen, path.substr(0, path.length-1)] // chop off trailing separator\n  } : (path, volumeNameLen) => {\n    if (path == \"\") {\n      return [volumeNameLen, \".\"]\n    }\n    if (path == DIRSEP) {\n      // do nothing to the path\n      return [volumeNameLen, path]\n    }\n    return [volumeNameLen, path.substr(0, path.length-1)] // chop off trailing separator\n  }\n)\n\n\nfunction isPathSep(s, i) {\n  return s.charCodeAt(i) === DIRSEP_BYTE\n}\n\n\n// (\"/foo///\") => \"/foo\"\nfunction stripDirSepRight(s) {\n  let e = s.length - 1, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p--\n  }\n  return p != e ? s.substr(0, p + 1) : s\n}\n\n// (\"///foo/\") => \"foo/\"\nfunction stripDirSepLeft(s) {\n  let e = 0, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p++\n  }\n  return p != e ? s.substr(p) : s\n}\n\n\n// deepglob(parts :string[]) string[] | null\n//\nfunction deepglob(dir, parts, partIndex, matches, filesVisited) {\n  if (partIndex >= parts.length) {\n    partIndex = parts.length - 1\n  }\n\n  let part = parts[partIndex]\n  let pattern = part\n\n  if (partIndex === 0) {\n    // first part\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"part/**\"\n  } else if (partIndex === parts.length-1) {\n    // last part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part\"\n  } else {\n    // mid part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part**\"\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"**part/**\"\n  }\n\n\n  function markVisit(path) {\n    if (filesVisited.has(path)) {\n      return false\n    }\n    filesVisited.add(path)\n    return true\n  }\n\n\n  function maybeAddFile(path) {\n    let filename = path\n    let p = filename.lastIndexOf(DIRSEP)\n    if (p != -1) {\n      filename = filename.substr(p + 1)\n    }\n\n    let nextPartIndex = Math.min(partIndex + 1, parts.length - 1)\n    let pat = parts.slice(nextPartIndex).join('*')\n\n    if (pat.charCodeAt(0) == DIRSEP_BYTE) {\n      pat = stripDirSepLeft(pat)\n    } else if (pat[0] != '*') {\n      pat = '*' + pat\n    }\n\n    if (match(pat, filename)) {\n      matches.push(path)\n    }\n  }\n\n  if (dir) {\n    if (pattern[0] != DIRSEP) {\n      pattern = dir + DIRSEP + pattern\n    } else {\n      pattern = dir + pattern\n    }\n  }\n\n  let isDirPattern = false\n  if (pattern.charCodeAt(pattern.length-1) === DIRSEP_BYTE) {\n    isDirPattern = true\n    pattern = stripDirSepRight(pattern)\n  }\n\n  let paths = glob0(pattern)\n\n  for (let path of paths) {\n    let st = statSync(path)\n\n    if (st.isDirectory()) {\n      if (markVisit(path)) {\n        walkdir(path, (path, st) => {\n          if (markVisit(path)) {\n            if (st.isDirectory()) {\n              deepglob(path, parts, partIndex + 1, matches, filesVisited)\n            } else {\n              maybeAddFile(path)\n            }\n          }\n        })\n      }\n    } else if (!isDirPattern && markVisit(path)) {\n      maybeAddFile(path)\n    }\n  }\n\n  return matches\n}\n\n\nfunction walkdir(dir, callback) {\n  dir = pclean(dir)\n  let st = statSync(dir)\n  if (st.isDirectory()) {\n    _walkdir(dir, callback, new Set([st.ino]))\n  }\n}\n\n\nfunction _walkdir(dir, callback, visitedInodes) {\n  for (let name of readdirSync(dir)) {\n    let path = pjoin(dir, name)\n    let st = stat(path)\n    let result = callback(path, st)\n    if (\n      (result || result === undefined) &&\n      st && st.isDirectory() && !visitedInodes.has(st.ino)\n    ) {\n      visitedInodes.add(st.ino)\n      _walkdir(path, callback, visitedInodes)\n    }\n  }\n}\n\n\n// Glob returns the names of all files matching pattern or null\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible error is 'bad pattern', when pattern is malformed.\n//\n// glob(pattern :string) : string[] | null (matches)\nfunction glob0(pattern) {\n  let matches = []\n\n  if (!hasMeta(pattern)) {\n    if (stat(pattern)) {\n      return [pattern]\n    }\n    return matches\n  }\n\n  // dirname, basename\n  let volumeLen = volumeNameLen(pattern)\n  let i = pattern.length - 1\n  while (i >= volumeLen && !isPathSep(pattern, i)) {\n    i--\n  }\n  let dir = pattern.substr(0,i+1)\n  let file = pattern.substr(i+1)\n\n  ;[volumeLen, dir] = cleanGlobPath(dir, volumeLen)\n\n  if (!hasMeta(dir.substr(volumeLen))) {\n    _glob(dir, file, matches)\n  } else {\n    // Prevent infinite recursion. See golang issue 15879.\n    if (dir == pattern) {\n      throw new PatternError()\n    }\n    const m = glob0(dir) // :string[]\n    for (let d of m) {\n      _glob(d, file, matches)\n    }\n  }\n\n  return matches\n}\n\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\n//\n// _glob(dir :string, pattern :string, matches :string[])\n//\nfunction _glob(dir, pattern, matches) {\n  const fi = stat(dir)\n  if (fi === null) {\n    return\n  }\n  if (!fi.isDirectory()) {\n    return\n  }\n\n  let names\n  try {\n    names = readdirSync(dir)\n  } catch (_) {\n    return\n  }\n  names.sort()\n\n  for (let n of names) {\n    if (match(pattern, n)) {\n      matches.push(pjoin(dir, n))\n    }\n  }\n}\n\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by match.\nfunction hasMeta(path /*string*/) /*bool*/ {\n  for (let i = 0; i < path.length; ++i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2A: // *\n      case 0x3F: // ?\n      case 0x5B: // [\n      case 0x7B: // {\n        return true\n    }\n  }\n  return false\n}\n\n\n// strContainsCh(s :string, c :int) : bool\nfunction strContainsCh(s, c) {\n  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i) === c) {\n      return true\n    }\n  }\n  return false\n}\n\n\n// Match reports whether name matches the shell file name pattern.\n// The pattern syntax is:\n//\n//  pattern:\n//    { term }\n//  term:\n//    '*'         matches any sequence of non-Separator characters\n//    '?'         matches any single non-Separator character\n//    '[' [ '^' ] { character-range } ']'\n//                character class (must be non-empty)\n//    c           matches character c (c != '*', '?', '\\\\', '[')\n//    '\\\\' c      matches character c\n//\n//  character-range:\n//    c           matches character c (c != '\\\\', '-', ']')\n//    '\\\\' c      matches character c\n//    lo '-' hi   matches character c for lo <= c <= hi\n//\n// Match requires pattern to match all of name, not just a substring.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n// path separator.\n//\n// match(pattern :string, name :string) : bool (matched)\n//\nexport function match(pattern, name) {\n  Pattern:\n  while (pattern.length > 0) {\n    let star = false // :bool\n    let chunk = \"\" // :string\n\n    let patternin = pattern\n    ;[star, chunk, pattern] = scanChunk(pattern)\n    log(`scanChunk(%o) => %o`, patternin, [star, chunk, pattern])\n\n    if (star && chunk == \"\") {\n      log('ret')\n      // Trailing * matches rest of string unless it has a /.\n      return !strContainsCh(name, DIRSEP_BYTE)\n    }\n\n    // Look for match at current position.\n    let [t, ok] = matchChunk(chunk, name)\n    log(`matchChunk(%o, %o) => %o`, chunk, name, [t, ok])\n\n    // if we're the last chunk, make sure we've exhausted the name\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length == 0 || pattern.length > 0)) {\n      name = t\n      continue\n    }\n\n    if (star) {\n      // Look for match skipping i+1 bytes.\n      // Cannot skip /.\n      for (let i = 0; i < name.length && name.charCodeAt(i) != DIRSEP_BYTE; i++) {\n        ;[t, ok] = matchChunk(chunk, name.substr(i+1))\n        if (ok) {\n          // if we're the last chunk, make sure we exhausted the name\n          if (pattern.length == 0 && t.length > 0) {\n            continue\n          }\n          name = t\n          continue Pattern\n        }\n      }\n    }\n\n    return false\n  }\n\n  return name.length == 0\n}\n\n\n// scanChunk gets the next segment of pattern, which is a non-star string\n// possibly preceded by a star.\n//\n// scanChunk(pattern :string) : [star bool, chunk string, rest string]\nfunction scanChunk(pattern) {\n  let star = false\n  while (pattern.length > 0 && pattern.charCodeAt(0) == 0x2A) {  // *\n    pattern = pattern.substr(1)\n    star = true\n  }\n  let inrange = false\n  let i = 0 >> 0 // int\n\n  Scan:\n  for (; i < pattern.length; i++) {\n    switch (pattern.charCodeAt(i)) {\n    case 0x5C: // \\\n      if (!WIN32) {\n        // error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n      }\n      break\n    case 0x5B: // [\n      inrange = true\n      break\n    case 0x5D: // ]\n      inrange = false\n      break\n    case 0x2A: // *\n      if (!inrange) {\n        break Scan\n      }\n      break\n    }\n  }\n  return [ star, pattern.substr(0,i), pattern.substr(i) ]\n}\n\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n//\n// matchChunk(chunk :string, s :string) [rest string, ok bool]\n//\nfunction matchChunk(chunk, s) {\n  log('enter matchChunk(%o, %o)', chunk, s)\n\n  while (chunk.length > 0) {\n    if (s.length == 0) {\n      return [\"\", false]\n    }\n\n    switch (chunk.charCodeAt(0)) {\n\n    case 0x5B: { // [\n      // character class\n      // let [r, n] = utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      log('\"[\" s reduced to %o, chunk reduced to %o, r = 0x%s', s, chunk, r.toString(16))\n\n      // We can't end right after '[', we're expecting at least\n      // a closing bracket and possibly a caret.\n      if (chunk.length == 0) {\n        throw new PatternError()\n      }\n      // possibly negated\n      let negated = chunk.charCodeAt(0) == 0x5E // ^\n      if (negated) {\n        log('\"[\" negation from \"^\"')\n        chunk = chunk.substr(1)\n      }\n      // parse all ranges\n      let match = false\n      let nrange = 0\n      while (true) {\n        if (chunk.length > 0 && chunk.charCodeAt(0) == 0x5D /*]*/ && nrange > 0) {\n          log('\"[\" loop break at A')\n          chunk = chunk.substr(1)\n          break\n        }\n\n        let ok, lo // bool, unichar\n        let debug_chunk = chunk\n        ;[ lo, chunk, ok ] = getEsc(chunk) // [ok bool, r rune, nchunk string]\n        log('\"[\" loop getEsc(%o) => %o', debug_chunk, [ lo, chunk, ok ])\n        if (!ok) {\n          log('\"[\" loop return at B from failed getEsc')\n          return [\"\", false]\n        }\n\n        let hi = lo\n        if (chunk.charCodeAt(0) == 0x2D /*-*/) {\n          ;[ hi, chunk, ok ] = getEsc(chunk.substr(1))\n          if (!ok) {\n            return [\"\", false]\n          }\n        }\n\n        if (lo <= r && r <= hi) {\n          match = true\n        }\n\n        nrange++\n      }\n      if (match == negated) {\n        return [\"\", false]\n      }\n      break\n    }\n\n    case 0x3F: // ?\n      if (s.charCodeAt(0) == DIRSEP_BYTE) {\n        return [\"\", false]\n      }\n      // _, n := utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      break\n\n    case 0x5C: // \\\n      if (!WIN32) {\n        log('\"\\\\\" consume')\n        chunk = chunk.substr(1)\n        if (chunk.length == 0) {\n          throw new PatternError()\n        }\n      }\n      // fallthrough\n\n    default:\n      if (chunk.charCodeAt(0) != s.charCodeAt(0)) {\n        log('[def] chunk[0] != s[0] (%o != %o) (0x%s != 0x%s) -- return',\n          chunk[0], s[0], chunk.charCodeAt(0).toString(16), s.charCodeAt(0).toString(16))\n        return [\"\", false]\n      }\n      s = s.substr(1)\n      chunk = chunk.substr(1)\n      log('[def] s reduced to %o, chunk reduced to %o', s, chunk)\n      break\n\n    }\n  }\n\n  return [ s, true ]\n}\n\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\n//\n// getEsc(chunk :string) : [ r rune, nchunk string, ok bool ]\n//\nfunction getEsc(chunk) {\n  let r = 0\n  let nchunk = ''\n  let c = chunk.charCodeAt(0)\n  if (chunk.length == 0 || c == 0x2D /*-*/ || c == 0x5D /*]*/) {\n    throw new PatternError()\n  }\n  if (c == 0x5C /*\\*/ && !WIN32) {\n    chunk = chunk.substr(1)\n    if (chunk.length == 0) {\n      throw new PatternError()\n    }\n  }\n  r = chunk.codePointAt(0)\n  let n = r <= 0xFFFF ? 1 : 2\n  if (r == 0xFFFF && n == 1) {\n    throw new PatternError()\n  }\n  nchunk = chunk.substr(n)\n  if (nchunk.length == 0) {\n    throw new PatternError()\n  }\n  return [ r, nchunk, true ]\n}\n\n\nfunction stat(path) {\n  try { return statSync(path) } catch (_) {}\n  return null\n}\n\n\nfunction pjoin(path1, path2) {\n  return (path1 == '.' || path1 == '') ? path2 : path1 + DIRSEP + path2\n}\n\n\n// pclean(\"foo//bar//\") => \"foo/bar\"\nfunction pclean(path) {\n  let endi = path.length - 1, i = endi\n  while (i && path.charCodeAt(i) === DIRSEP_BYTE) { --i }\n  if (i != endi) {\n    path = path.substr(0, i + 1)\n  }\n  return path.split(DIRSEP_RE_PG).join(DIRSEP)\n}\n", "//\n// miniglob is a port of golang path/filepath\n//\n// Original Go source code Copyright (c) 2009 The Go Authors.\n// All rights reserved. See LICENSE-go for complete license.\n//\n// This code licensed under MIT, Copyright (c) 2018 Rasmus Andersson.\n// See LICENSE for complete license.\n//\nconst { readdirSync, statSync } = require('fs')\nconst DIRSEP = (() => {try {return require('path').sep}catch(_){return '/'}})()\nconst DIRSEP_BYTE = DIRSEP.charCodeAt(0)\nconst DIRSEP_RE_PG = DIRSEP == ':' ? /\\:+/g : DIRSEP == '\\\\' ? /\\\\+/g : /\\/+/g\nconst WIN32 = process.platform == 'win32'\n\n\nexport class PatternError extends Error {\n  constructor() { super('bad pattern') }\n}\n\n\nexport function glob(pattern) {\n  if (pattern.indexOf(\"**\") < 0) {\n    return glob0(pattern)\n  }\n  let matches = []\n  let filesVisited = new Set()\n  deepglob('', pattern.split(/\\*{2,}/), 0, matches, filesVisited)\n  return matches\n}\n\n\nfunction log() {\n  // console.log.apply(console, arguments)\n}\n\n\n// volumeNameLen returns length of the leading volume name on Windows.\n// It returns 0 elsewhere.\nconst volumeNameLen = WIN32 ? path => {\n  if (path.length < 2) {\n    return 0\n  }\n  // with drive letter\n  let c = path[0]\n  if (path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z')) {\n    return 2\n  }\n  // TODO: check for UNC\n  return 0\n} : path => 0\n\n\n// cleanGlobPath prepares path for glob matching.\n// cleanGlobPath(path :string) : [prefixLen int, cleaned string]\n//\nconst cleanGlobPath = (\n  WIN32 ? (path, volumeNameLen) => { // (prefixLen int, cleaned string)\n    let vollen = volumeNameLen(path)\n    if (path == \"\") {\n      return [0, \".\"]\n    }\n    if (vollen+1 == path.length && isPathSep(path, path.length-1)) {\n      // /, \\, C:\\ and C:/ -- do nothing to the path\n      return [vollen + 1, path]\n    }\n    if (vollen == path.length && path.length == 2) { // C:\n      return [vollen, path + \".\"] // convert C: into C:.\n    }\n    if (vollen >= path.length) {\n      vollen = path.length - 1\n    }\n    return [vollen, path.substr(0, path.length-1)] // chop off trailing separator\n  } : (path, volumeNameLen) => {\n    if (path == \"\") {\n      return [volumeNameLen, \".\"]\n    }\n    if (path == DIRSEP) {\n      // do nothing to the path\n      return [volumeNameLen, path]\n    }\n    return [volumeNameLen, path.substr(0, path.length-1)] // chop off trailing separator\n  }\n)\n\n\nfunction isPathSep(s, i) {\n  return s.charCodeAt(i) === DIRSEP_BYTE\n}\n\n\n// (\"/foo///\") => \"/foo\"\nfunction stripDirSepRight(s) {\n  let e = s.length - 1, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p--\n  }\n  return p != e ? s.substr(0, p + 1) : s\n}\n\n// (\"///foo/\") => \"foo/\"\nfunction stripDirSepLeft(s) {\n  let e = 0, p = e\n  while (s.charCodeAt(p) === DIRSEP_BYTE) {\n    p++\n  }\n  return p != e ? s.substr(p) : s\n}\n\n\n// deepglob(parts :string[]) string[] | null\n//\nfunction deepglob(dir, parts, partIndex, matches, filesVisited) {\n  if (partIndex >= parts.length) {\n    partIndex = parts.length - 1\n  }\n\n  let part = parts[partIndex]\n  let pattern = part\n\n  if (partIndex === 0) {\n    // first part\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"part/**\"\n  } else if (partIndex === parts.length-1) {\n    // last part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part\"\n  } else {\n    // mid part\n    if (part.charCodeAt(0) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"*part\"\n      pattern = '*' + pattern\n    } // else e.g. input=\"**/part**\"\n    if (part.charCodeAt(part.length - 1) != DIRSEP_BYTE) {\n      // e.g. input=\"**part**\"; part=\"part\"; pattern=\"part*\"\n      pattern += '*'\n    } // else e.g. input=\"**part/**\"\n  }\n\n\n  function markVisit(path) {\n    if (filesVisited.has(path)) {\n      return false\n    }\n    filesVisited.add(path)\n    return true\n  }\n\n\n  function maybeAddFile(path) {\n    let filename = path\n    let p = filename.lastIndexOf(DIRSEP)\n    if (p != -1) {\n      filename = filename.substr(p + 1)\n    }\n\n    let nextPartIndex = Math.min(partIndex + 1, parts.length - 1)\n    let pat = parts.slice(nextPartIndex).join('*')\n\n    if (pat.charCodeAt(0) == DIRSEP_BYTE) {\n      pat = stripDirSepLeft(pat)\n    } else if (pat[0] != '*') {\n      pat = '*' + pat\n    }\n\n    if (match(pat, filename)) {\n      matches.push(path)\n    }\n  }\n\n  if (dir) {\n    if (pattern[0] != DIRSEP) {\n      pattern = dir + DIRSEP + pattern\n    } else {\n      pattern = dir + pattern\n    }\n  }\n\n  let isDirPattern = false\n  if (pattern.charCodeAt(pattern.length-1) === DIRSEP_BYTE) {\n    isDirPattern = true\n    pattern = stripDirSepRight(pattern)\n  }\n\n  let paths = glob0(pattern)\n\n  for (let path of paths) {\n    let st = statSync(path)\n\n    if (st.isDirectory()) {\n      if (markVisit(path)) {\n        walkdir(path, (path, st) => {\n          if (markVisit(path)) {\n            if (st.isDirectory()) {\n              deepglob(path, parts, partIndex + 1, matches, filesVisited)\n            } else {\n              maybeAddFile(path)\n            }\n          }\n        })\n      }\n    } else if (!isDirPattern && markVisit(path)) {\n      maybeAddFile(path)\n    }\n  }\n\n  return matches\n}\n\n\nfunction walkdir(dir, callback) {\n  dir = pclean(dir)\n  let st = statSync(dir)\n  if (st.isDirectory()) {\n    _walkdir(dir, callback, new Set([st.ino]))\n  }\n}\n\n\nfunction _walkdir(dir, callback, visitedInodes) {\n  for (let name of readdirSync(dir)) {\n    let path = pjoin(dir, name)\n    let st = stat(path)\n    let result = callback(path, st)\n    if (\n      (result || result === undefined) &&\n      st && st.isDirectory() && !visitedInodes.has(st.ino)\n    ) {\n      visitedInodes.add(st.ino)\n      _walkdir(path, callback, visitedInodes)\n    }\n  }\n}\n\n\n// Glob returns the names of all files matching pattern or null\n// if there is no matching file. The syntax of patterns is the same\n// as in Match. The pattern may describe hierarchical names such as\n// /usr/*/bin/ed (assuming the Separator is '/').\n//\n// Glob ignores file system errors such as I/O errors reading directories.\n// The only possible error is 'bad pattern', when pattern is malformed.\n//\n// glob(pattern :string) : string[] | null (matches)\nfunction glob0(pattern) {\n  let matches = []\n\n  if (!hasMeta(pattern)) {\n    if (stat(pattern)) {\n      return [pattern]\n    }\n    return matches\n  }\n\n  // dirname, basename\n  let volumeLen = volumeNameLen(pattern)\n  let i = pattern.length - 1\n  while (i >= volumeLen && !isPathSep(pattern, i)) {\n    i--\n  }\n  let dir = pattern.substr(0,i+1)\n  let file = pattern.substr(i+1)\n\n  ;[volumeLen, dir] = cleanGlobPath(dir, volumeLen)\n\n  if (!hasMeta(dir.substr(volumeLen))) {\n    _glob(dir, file, matches)\n  } else {\n    // Prevent infinite recursion. See golang issue 15879.\n    if (dir == pattern) {\n      throw new PatternError()\n    }\n    const m = glob0(dir) // :string[]\n    for (let d of m) {\n      _glob(d, file, matches)\n    }\n  }\n\n  return matches\n}\n\n\n// glob searches for files matching pattern in the directory dir\n// and appends them to matches. If the directory cannot be\n// opened, it returns the existing matches. New matches are\n// added in lexicographical order.\n//\n// _glob(dir :string, pattern :string, matches :string[])\n//\nfunction _glob(dir, pattern, matches) {\n  const fi = stat(dir)\n  if (fi === null) {\n    return\n  }\n  if (!fi.isDirectory()) {\n    return\n  }\n\n  let names\n  try {\n    names = readdirSync(dir)\n  } catch (_) {\n    return\n  }\n  names.sort()\n\n  for (let n of names) {\n    if (match(pattern, n)) {\n      matches.push(pjoin(dir, n))\n    }\n  }\n}\n\n\n// hasMeta reports whether path contains any of the magic characters\n// recognized by match.\nfunction hasMeta(path /*string*/) /*bool*/ {\n  for (let i = 0; i < path.length; ++i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2A: // *\n      case 0x3F: // ?\n      case 0x5B: // [\n      case 0x7B: // {\n        return true\n    }\n  }\n  return false\n}\n\n\n// strContainsCh(s :string, c :int) : bool\nfunction strContainsCh(s, c) {\n  for (let i = 0; i < s.length; ++i) {\n    if (s.charCodeAt(i) === c) {\n      return true\n    }\n  }\n  return false\n}\n\n\n// Match reports whether name matches the shell file name pattern.\n// The pattern syntax is:\n//\n//  pattern:\n//    { term }\n//  term:\n//    '*'         matches any sequence of non-Separator characters\n//    '?'         matches any single non-Separator character\n//    '[' [ '^' ] { character-range } ']'\n//                character class (must be non-empty)\n//    c           matches character c (c != '*', '?', '\\\\', '[')\n//    '\\\\' c      matches character c\n//\n//  character-range:\n//    c           matches character c (c != '\\\\', '-', ']')\n//    '\\\\' c      matches character c\n//    lo '-' hi   matches character c for lo <= c <= hi\n//\n// Match requires pattern to match all of name, not just a substring.\n// The only possible returned error is ErrBadPattern, when pattern\n// is malformed.\n//\n// On Windows, escaping is disabled. Instead, '\\\\' is treated as\n// path separator.\n//\n// match(pattern :string, name :string) : bool (matched)\n//\nexport function match(pattern, name) {\n  Pattern:\n  while (pattern.length > 0) {\n    let star = false // :bool\n    let chunk = \"\" // :string\n\n    let patternin = pattern\n    ;[star, chunk, pattern] = scanChunk(pattern)\n    log(`scanChunk(%o) => %o`, patternin, [star, chunk, pattern])\n\n    if (star && chunk == \"\") {\n      log('ret')\n      // Trailing * matches rest of string unless it has a /.\n      return !strContainsCh(name, DIRSEP_BYTE)\n    }\n\n    // Look for match at current position.\n    let [t, ok] = matchChunk(chunk, name)\n    log(`matchChunk(%o, %o) => %o`, chunk, name, [t, ok])\n\n    // if we're the last chunk, make sure we've exhausted the name\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length == 0 || pattern.length > 0)) {\n      name = t\n      continue\n    }\n\n    if (star) {\n      // Look for match skipping i+1 bytes.\n      // Cannot skip /.\n      for (let i = 0; i < name.length && name.charCodeAt(i) != DIRSEP_BYTE; i++) {\n        ;[t, ok] = matchChunk(chunk, name.substr(i+1))\n        if (ok) {\n          // if we're the last chunk, make sure we exhausted the name\n          if (pattern.length == 0 && t.length > 0) {\n            continue\n          }\n          name = t\n          continue Pattern\n        }\n      }\n    }\n\n    return false\n  }\n\n  return name.length == 0\n}\n\n\n// scanChunk gets the next segment of pattern, which is a non-star string\n// possibly preceded by a star.\n//\n// scanChunk(pattern :string) : [star bool, chunk string, rest string]\nfunction scanChunk(pattern) {\n  let star = false\n  while (pattern.length > 0 && pattern.charCodeAt(0) == 0x2A) {  // *\n    pattern = pattern.substr(1)\n    star = true\n  }\n  let inrange = false\n  let i = 0 >> 0 // int\n\n  Scan:\n  for (; i < pattern.length; i++) {\n    switch (pattern.charCodeAt(i)) {\n    case 0x5C: // \\\n      if (!WIN32) {\n        // error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n      }\n      break\n    case 0x5B: // [\n      inrange = true\n      break\n    case 0x5D: // ]\n      inrange = false\n      break\n    case 0x2A: // *\n      if (!inrange) {\n        break Scan\n      }\n      break\n    }\n  }\n  return [ star, pattern.substr(0,i), pattern.substr(i) ]\n}\n\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n//\n// matchChunk(chunk :string, s :string) [rest string, ok bool]\n//\nfunction matchChunk(chunk, s) {\n  log('enter matchChunk(%o, %o)', chunk, s)\n\n  while (chunk.length > 0) {\n    if (s.length == 0) {\n      return [\"\", false]\n    }\n\n    switch (chunk.charCodeAt(0)) {\n\n    case 0x5B: { // [\n      // character class\n      // let [r, n] = utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      log('\"[\" s reduced to %o, chunk reduced to %o, r = 0x%s', s, chunk, r.toString(16))\n\n      // We can't end right after '[', we're expecting at least\n      // a closing bracket and possibly a caret.\n      if (chunk.length == 0) {\n        throw new PatternError()\n      }\n      // possibly negated\n      let negated = chunk.charCodeAt(0) == 0x5E // ^\n      if (negated) {\n        log('\"[\" negation from \"^\"')\n        chunk = chunk.substr(1)\n      }\n      // parse all ranges\n      let match = false\n      let nrange = 0\n      while (true) {\n        if (chunk.length > 0 && chunk.charCodeAt(0) == 0x5D /*]*/ && nrange > 0) {\n          log('\"[\" loop break at A')\n          chunk = chunk.substr(1)\n          break\n        }\n\n        let ok, lo // bool, unichar\n        let debug_chunk = chunk\n        ;[ lo, chunk, ok ] = getEsc(chunk) // [ok bool, r rune, nchunk string]\n        log('\"[\" loop getEsc(%o) => %o', debug_chunk, [ lo, chunk, ok ])\n        if (!ok) {\n          log('\"[\" loop return at B from failed getEsc')\n          return [\"\", false]\n        }\n\n        let hi = lo\n        if (chunk.charCodeAt(0) == 0x2D /*-*/) {\n          ;[ hi, chunk, ok ] = getEsc(chunk.substr(1))\n          if (!ok) {\n            return [\"\", false]\n          }\n        }\n\n        if (lo <= r && r <= hi) {\n          match = true\n        }\n\n        nrange++\n      }\n      if (match == negated) {\n        return [\"\", false]\n      }\n      break\n    }\n\n    case 0x3F: // ?\n      if (s.charCodeAt(0) == DIRSEP_BYTE) {\n        return [\"\", false]\n      }\n      // _, n := utf8.DecodeRuneInString(s)\n      let r = s.codePointAt(0)\n      let n = r <= 0xFFFF ? 1 : 2\n      s = s.substr(n)\n      chunk = chunk.substr(1)\n      break\n\n    case 0x5C: // \\\n      if (!WIN32) {\n        log('\"\\\\\" consume')\n        chunk = chunk.substr(1)\n        if (chunk.length == 0) {\n          throw new PatternError()\n        }\n      }\n      // fallthrough\n\n    default:\n      if (chunk.charCodeAt(0) != s.charCodeAt(0)) {\n        log('[def] chunk[0] != s[0] (%o != %o) (0x%s != 0x%s) -- return',\n          chunk[0], s[0], chunk.charCodeAt(0).toString(16), s.charCodeAt(0).toString(16))\n        return [\"\", false]\n      }\n      s = s.substr(1)\n      chunk = chunk.substr(1)\n      log('[def] s reduced to %o, chunk reduced to %o', s, chunk)\n      break\n\n    }\n  }\n\n  return [ s, true ]\n}\n\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\n//\n// getEsc(chunk :string) : [ r rune, nchunk string, ok bool ]\n//\nfunction getEsc(chunk) {\n  let r = 0\n  let nchunk = ''\n  let c = chunk.charCodeAt(0)\n  if (chunk.length == 0 || c == 0x2D /*-*/ || c == 0x5D /*]*/) {\n    throw new PatternError()\n  }\n  if (c == 0x5C /*\\*/ && !WIN32) {\n    chunk = chunk.substr(1)\n    if (chunk.length == 0) {\n      throw new PatternError()\n    }\n  }\n  r = chunk.codePointAt(0)\n  let n = r <= 0xFFFF ? 1 : 2\n  if (r == 0xFFFF && n == 1) {\n    throw new PatternError()\n  }\n  nchunk = chunk.substr(n)\n  if (nchunk.length == 0) {\n    throw new PatternError()\n  }\n  return [ r, nchunk, true ]\n}\n\n\nfunction stat(path) {\n  try { return statSync(path) } catch (_) {}\n  return null\n}\n\n\nfunction pjoin(path1, path2) {\n  return (path1 == '.' || path1 == '') ? path2 : path1 + DIRSEP + path2\n}\n\n\n// pclean(\"foo//bar//\") => \"foo/bar\"\nfunction pclean(path) {\n  let endi = path.length - 1, i = endi\n  while (i && path.charCodeAt(i) === DIRSEP_BYTE) { --i }\n  if (i != endi) {\n    path = path.substr(0, i + 1)\n  }\n  return path.split(DIRSEP_RE_PG).join(DIRSEP)\n}\n"],
  "mappings": "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",
  "names": []
}
